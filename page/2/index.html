<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/static/css/style.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%2210 0 100 100%22><text y=%22.90em%22 font-size=%2290%22>🐱</text></svg>">
	<title>Yarnom&#x27;Blog</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
    
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ]
            });
        });
    </script>

    <script async src="https://umami.yarnom.com/script.js" data-website-id="049fbfba-0566-421e-9137-533851ed8c60"></script>
</head>
<body>
    <header>
    <div class="nav_area">
        <div class="logo">
            <a href="/">Yarnom&#x27;Blog</a>
            <div class="menu_mobile" onclick="toggleMenu()">
                <span class="menu_icon">&#9776;</span> <!-- Unicode hamburger icon -->
            </div>
        </div>

        <div class="nav_bar">
            <ul>
                
                    <li><a href="&#x2F;archive">归档</a></li>
                
                    <li><a href="&#x2F;archive&#x2F;tags">标签</a></li>
                
                    <li><a href="&#x2F;archive&#x2F;categories">分类 </a></li>
                
                    <li><a href="&#x2F;link">友链</a></li>
                
                    <li><a href="&#x2F;about">关于</a></li>
                
            </ul>
        </div>
    </div>
</header>
<script>
    function toggleMenu() {
    var menu = document.querySelector('.nav_bar');
        menu.classList.toggle('show_nav_bar');
    }
</script>

    
    <div class="main_container">
        <div class="main_content main_area">
            
    
    
        <div class="articles">
            <div class="post">
                <div class="header_post">
                    <div class="title_post"><a href="&#x2F;archive&#x2F;posts&#x2F;2023&#x2F;8&#x2F;31&#x2F;Rustic-pages 需求与开发文档.html">Rustic-pages 需求与开发文档</a></div>
                    <div class="detail_post">
                        <div class="date">发布时间：2023-08-31 12:36:47</div>
                        <div class="categories">
                            归档分类：
                            <ul>
                                
                                <li><a href="/archive/categories/开发">开发</a></li>
                                
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="content_post"><h2>1. 引言</h2>
<p>要求使用 Rust 编写一个高效且易于使用的静态博客生成器，它将能正确处理 Markdown 和 SCSS 文件的文件。</p>
<p>它将支持以下命令行指令：</p>
<ul>
<li>
<p><code>init</code>： 初始化程序，创建相应文件夹及内容</p>
</li>
<li>
<p><code>generate</code> : 渲染和生成所有的静态网站内容</p>
</li>
<li>
<p><code>clean</code> : 清除缓存</p>
</li>
<li>
<p><code>server</code> : 本地部署服务，该指令应该默认调用 <code>clean</code> 和 <code>generate</code></p>
</li>
<li>
<p><code>deploy</code> : 自动部署静态文件到指定仓库</p>
</li>
</ul>
<p>所有的内容应该均以变量的形式预先准备，然后再根据规则渲染文件。</p>
<h2>2. 功能需求</h2>
<h3>2.1 博文编辑</h3>
<ul>
<li>用户可以创建、编辑和删除博文。</li>
<li>博文内容支持 Markdown 格式，允许用户使用 Markdown 语法编写博文。</li>
<li>用户可以设置博文的标题、发布日期、标签和归档。</li>
<li>用户可以上传图片和附件，并在博文中引用它们。</li>
<li>用户可以保存博文为草稿，随时继续编辑。</li>
</ul>
<h3>2.2 博文生成</h3>
<ul>
<li>用户可以使用命令行工具生成静态网站。</li>
<li>博客生成器将从用户指定的目录中读取博文和资源文件，并生成静态 HTML 文件。</li>
<li>用户可以指定生成的网站目标路径。</li>
<li>生成的网站应包括主页、博文详细页、归档页、分类页面和标签页面。</li>
</ul>
<h3>2.3 主题和样式</h3>
<ul>
<li>用户可以选择不同的博客主题和样式。</li>
<li>博客生成器应支持多个默认主题，用户也可以自定义主题。</li>
<li>用户可以自定义网站的样式表（CSS）。</li>
</ul>
<h2>3. 功能模块</h2>
<h3>3.1 数据结构</h3>
<h4>3.1.1 Post</h4>
<ul>
<li>
<p>title: String</p>
</li>
<li>
<p>date: String</p>
</li>
<li>
<p>date_simple : String</p>
</li>
<li>
<p>published: bool</p>
</li>
<li>
<p>tags: Vec<!-- raw HTML omitted --></p>
</li>
<li>
<p>categories: Vec<!-- raw HTML omitted --></p>
</li>
<li>
<p>raw_content: String</p>
</li>
<li>
<p>content: String</p>
</li>
<li>
<p>slug: String</p>
</li>
<li>
<p>link: String</p>
</li>
</ul>
<h4>3.1.2 Page</h4>
<ul>
<li>
<p>title: String,</p>
</li>
<li>
<p>date: String,</p>
</li>
<li>
<p>template: String,</p>
</li>
<li>
<p>raw_content: String,</p>
</li>
<li>
<p>content: String,</p>
</li>
<li>
<p>limited_cows:usize,</p>
</li>
<li>
<p>total: usize,</p>
</li>
<li>
<p>current: usize,</p>
</li>
<li>
<p>prev:usize,</p>
</li>
<li>
<p>prev_link: String,</p>
</li>
<li>
<p>next:usize,</p>
</li>
<li>
<p>next_link: String</p>
</li>
</ul>
<h4>3.1.3 Archive</h4>
<ul>
<li>posts - Vec<!-- raw HTML omitted --></li>
<li>pages: Vec<!-- raw HTML omitted --></li>
<li>tags: HashMap&lt;String,Vec&lt;&amp; Post&gt;&gt;</li>
<li>categories: HashMap&lt;String,Vec&lt;&amp; Post&gt;&gt;</li>
</ul>
<h4>3.1.4 Config</h4>
<p>pass</p>
<h3>3.2 构建逻辑（Generate）</h3>
<ol>
<li>
<p>程序首先构造一个 Archive 实例，用于保存接下来所有的变量数据。</p>
</li>
<li>
<p>Post 处理过程</p>
<ol>
<li>从 /source/content/posts 中获取所有的 markdown 文件，并进行解析，封装为一个可操作的 Post 数据实例。</li>
<li>所有的Post 插入到  Archive.posts</li>
</ol>
</li>
<li>
<p>Tag 处理过程</p>
<ol>
<li>遍历 Archive.posts 将每个Post 内的 Tag 解析</li>
<li>所有的 Tag 插入到 Archive.tags</li>
</ol>
</li>
<li>
<p>Category 处理过程</p>
<ol>
<li>遍历 Archive.posts 将每个Post 内的 Category 解析</li>
<li>所有的 Category 插入到 Archive.categories</li>
</ol>
</li>
<li>
<p>页面构造逻辑</p>
<ol>
<li>从 /source/content/pages 中获取所有的 markdown 文件，进行解析，封装为一个可操作的 Page 数据实例</li>
<li>所有的 Page 插入到 Archive.pages</li>
<li>若是front-matter 带有 pagination: tags,则对 Archive.tags 触发分页</li>
<li>若是front-matter 带有 template: xxx ，则渲染模板，否则默认输出 content</li>
</ol>
</li>
</ol>
<h3>3.3 路径渲染逻辑</h3>
<ul>
<li>Index - Page
<ul>
<li>/public/index.html</li>
<li>/public/page/N/index.html</li>
</ul>
</li>
<li>Archive
<ul>
<li>/public/archive/posts/2023/12/10/hello/index.html</li>
<li>/public/archive/tags/技术/index.html</li>
<li>/public/archive/categories/算法/index.html</li>
</ul>
</li>
<li>Tags - Page
<ul>
<li>/public/tags/index.html</li>
<li>/public/tags/page/N/index.html</li>
</ul>
</li>
<li>Categories - Page
<ul>
<li>/public/categories/index.html</li>
<li>/public/categories/page/N/index.html</li>
</ul>
</li>
<li>Custom Page
<ul>
<li>/public/custom/index.html</li>
<li>/public/custom/page/N/index.html</li>
</ul>
</li>
</ul>
<h2>README 文档</h2>
<p>A lightweight static blog generator developed using Rust</p>
<h2>Usage</h2>
<p>You can compile the source code of this project using the cargo build command.</p>
<pre><code class="language-shell">cargo build
</code></pre>
<p>When you run cargo build, it searches for the Cargo.toml file in the current directory and builds the project based on the configuration information specified in that file.
<code>Cargo.toml</code> is the configuration file for Rust projects and contains the project's dependencies and other build configurations.</p>
</div>
                <div class="tags_post">
                    
                    <li><a href="/archive/tags/rustic-pages">rustic-pages</a></li>
                    
                    <li><a href="/archive/tags/需求文档">需求文档</a></li>
                    
                </div>
            </div>
        </div>
    
        <div class="articles">
            <div class="post">
                <div class="header_post">
                    <div class="title_post"><a href="&#x2F;archive&#x2F;posts&#x2F;2023&#x2F;8&#x2F;27&#x2F;我的静态博客生成器.html">我的静态博客生成器</a></div>
                    <div class="detail_post">
                        <div class="date">发布时间：2023-08-27 09:22:56</div>
                        <div class="categories">
                            归档分类：
                            <ul>
                                
                                <li><a href="/archive/categories/开发">开发</a></li>
                                
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="content_post"><p>近些日子无心向学，于是又手痒折腾起了代码。</p>
<p>起因是接触到了 Rust 这门语言，并了解到了它的很多特性。我认为这真的是一个很棒的语言并且惊叹于它的性能。正因如此，我决定以此为契机，开始了一个新的项目，一个使用 Rust 编写的静态博客生成器。</p>
<h2>项目情况</h2>
<p>目前它只是一个堪堪能用的状态，我甚至还没想好它的名字，现在只是使用 <code>static-blog-rust-make</code> 作为项目名字，我并没有想出一个正式的名字。我目前开源在<a href="https://github.com/fengyarnom/static-blog-rust-make">Github</a> 上，由于时间实在是不够用，我在有限的时间内已经做到了极限，优化代码和新功能的添加只能在日后完成了，但是，我仍然十分满意于这个项目！</p>
<p>虽然如此，这个生成器确实已经可以正常使用。我用它来重新生成了一个这个网站，并将之前为 Hexo 写的主题应用其中。目前的版本是 <em><strong>v0.03</strong></em> 。项目仅仅是一个粗劣地模仿 Hexo 的产物，并没有融入很多我的思考，很多核心功能也只是调用别人写好的包，但是这次的代码仍然给我很多地启示，我发觉我开始接触到了很多软件工程的内容，同时对一个项目的整体规划有了一些了解。总之，这一次的项目开发还是很有意思的，之后的一段时间会着手于新的开发文档，并希望能在书写开发文档的过程中，思考更多新的功能。</p>
<p>最后，这是一个非常不完美的项目，里面的代码混乱不堪，复杂的逻辑结构几乎把我压倒。在多次重构和清理冗杂代码后，确实完成了我一开始定下的所有功能需求，但是这样的代码总归让人看了倒胃口，但也只能在之后的日子里慢慢修改完善啦，至少它没有夭折在漫长的开发期中。我确实是以最快的速度开发的，为的就是减少枯燥，目前看来确实如此，我在耐心消耗殆尽前完成了这个项目。</p>
</div>
                <div class="tags_post">
                    
                    <li><a href="/archive/tags/开发日志">开发日志</a></li>
                    
                </div>
            </div>
        </div>
    
        <div class="articles">
            <div class="post">
                <div class="header_post">
                    <div class="title_post"><a href="&#x2F;archive&#x2F;posts&#x2F;2023&#x2F;8&#x2F;17&#x2F;你好，OrangePi Zero3！.html">你好，OrangePi Zero3！</a></div>
                    <div class="detail_post">
                        <div class="date">发布时间：2023-08-17 11:48:44</div>
                        <div class="categories">
                            归档分类：
                            <ul>
                                
                                <li><a href="/archive/categories/教程">教程</a></li>
                                
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="content_post"><p>本篇文章将详细地写下我配置这块单板计算机的全过程，之后若是有新的自托管服务也会在本文记录下来。</p>
<h2>购买</h2>
<p>自从接触 Linux 之后渴望得到一个树莓派了，奈何因为疫情导致了全球的芯片供应紧张，树莓派的价格水涨船高，价格已经远远超过了它的价值，更重要的是超过了我的预算，即使是二手的价格也非常不值当。总之，出于囊中羞涩的考虑，我最终选择了这块国产的派 —— <strong>OrangePi Zero3.</strong></p>
<p><img src="https://s2.loli.net/2023/08/27/uq5Lpt4VhGs3eTZ.png" alt="2023-08-17_12-27.png" /></p>
<p>我购买的是内存为 1.5G 的版本价格为一百出头，刚拿到快递的时候我就疑惑了， 为何如此之小！开箱后更是震惊，它甚至没有我的巴掌大呢！虽然但是，这还是很精致的，而且对于这样的设备而言，小其实是更好的，更方便搭载在其他的设备上。</p>
<p><img src="https://s2.loli.net/2023/08/27/ZeyCJqUun7NYE2I.jpg" alt="photo_6264513425795298480_y.jpg" /></p>
<p>除开这块板子，我还另外买了：</p>
<ul>
<li>亚克力的外壳</li>
<li>风扇+散热片</li>
<li>USB to TTL 用于串口调试</li>
<li>64G 闪迪 tf 卡</li>
</ul>
<p>关于系统镜像方面，我还是选择了熟悉的 debian 发行版，毕竟我的 vps 用的也是这个，这块单板计算机我是拿来内网穿透的 <a href="http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/service-and-support/Orange-Pi-Zero-3.html">官方镜像</a></p>
<p><img src="https://s2.loli.net/2023/08/27/2gtelYJwAKvsV8X.png" alt="2023-08-17_12-42.png" /></p>
<h2>系统配置</h2>
<p>在向 tf 卡刷完系统后，就可以通过串口进行连接了。</p>
<h3>自动连接热点 WiFi</h3>
<p>使用串口多少是不方便的，所以先来配置一下网络，让其他机器可以通过 ssh 访问这块板子。</p>
<ol>
<li>
<p>使用<code>nmcli dev wifi</code>查看当前扫描到的 wifi 列表。</p>
</li>
<li>
<p>使用 <code>nmcli</code> 连接到热点并输入密码：</p>
</li>
</ol>
<pre><code class="language-bash">sudo nmcli dev wifi connect YourHotspotName password YourPassword
</code></pre>
<ol start="3">
<li>将连接的配置设置为自动连接：</li>
</ol>
<pre><code class="language-bash">sudo nmcli connection modify &quot;YourHotspotName&quot; connection.autoconnect yes
</code></pre>
<p>将 <code>YourHotspotName</code> 替换为你的热点名称，<code>YourPassword</code> 替换为密码。</p>
<p>完成后通过 <code>ip addr </code> 即可看到 ip 地址，然后就可以通过 ssh 正常访问板子了</p>
<h3>添加一个新用户</h3>
<pre><code>useradd -m -G additional_groups -s login_shell username
</code></pre>
<pre><code class="language-bash">passwd username
</code></pre>
<p>然后去修改<code> /etc/sudoers</code> 文件</p>
<h2>FRP 内网穿透</h2>
<p>在这个 <a href="https://github.com/fatedier/frp/releases">releases</a> 页面中，找到对应架构的压缩包，可以使用 <code>uname -a </code> 查看到。</p>
<ul>
<li>我的 VPS 是 X86_64 那么就选择 <a href="https://github.com/fatedier/frp/releases/download/v0.51.3/frp_0.51.3_linux_amd64.tar.gz">amd64.tar.gz</a> 的包</li>
<li>香橙派是 arm 架构，那么就选择 <a href="https://github.com/fatedier/frp/releases/download/v0.51.3/frp_0.51.3_linux_arm64.tar.gz">arm64.tar.gz </a>的包</li>
</ul>
<p>通过 <code>wget</code> 下载</p>
<pre><code class="language-bash">wget https://github.com/fatedier/frp/releases/download/v0.51.3/frp_0.51.3_linux_arm64.tar.gz
</code></pre>
<p>通过 <code>tar</code> 解压</p>
<pre><code class="language-bash">tar xvf frp_0.51.3_linux_arm64.tar.gz
</code></pre>
<ul>
<li><strong>frpc</strong>: 这是 FRP 客户端的可执行文件。FRP 客户端用于连接到 FRP 服务器并将内部网络服务暴露给外部访问。</li>
<li><strong>frps</strong>: 这是 FRP 服务器的可执行文件。FRP 服务器用于接收来自客户端的连接，并将这些连接转发到内部的网络服务。</li>
<li><strong>frpc.ini</strong>: 这是 FRP 客户端的配置文件，用于指定客户端的连接设置、代理规则等。</li>
<li><strong>frps.ini</strong>: 这是 FRP 服务器的配置文件，用于指定服务器的监听端口、代理规则等。</li>
<li><strong>frpc_full.ini</strong>: 这是 FRP 客户端的完整配置文件，可能包含更多详细的设置。</li>
<li><strong>frps_full.ini</strong>: 这是 FRP 服务器的完整配置文件，可能包含更多详细的设置。</li>
</ul>
<h3>服务器配置</h3>
<p>下载完对应架构的文件后，即可开始配置，只需要关心 <code>frps</code> 和 <code>frps.ini</code> 文件即可，前者是FRP 服务器的可执行文件，后者是这是 FRP 服务器的配置文件。</p>
<p>打开 <code>frps.ini</code>进行配置，配置文件的内容如下：</p>
<pre><code class="language-ini">[common]
bind_port = 7000
token = 1234567890
</code></pre>
<p>客户端和服务器的配置文件中都需要设置相同的 Token 才能正确进行连接和通信。</p>
<p>为了保障安全性，你应该选择一个强密码的 Token，并确保不会轻易泄露给他人。如果你怀疑 Token 可能已经暴露，应当立即生成一个新的 Token 并更新配置文件。</p>
<p>完成后，运行 <code>./frpc -c ./frpc.ini</code></p>
<p>若无问题，则说明配置成功。</p>
<p>接下来，配置一下 systemd 服务，让上面这条运行命令能开机自动启动，这非常实用：</p>
<p>但是在此之前，我们需要先将 <code>frps</code> 和 <code>frps.ini</code> 文件放到合适的地方：</p>
<pre><code>sudo cp frps /usr/local/bin/
sudo mkdir /usr/local/etc/frp
sudo cp frps.ini /usr/local/etc/frp/
</code></pre>
<p>首先，创建一个名为<code>frps.service</code>的文件，该文件将存储有关你的自启动服务的信息。通常，这些文件存放在<code>/etc/systemd/system/</code>目录下。</p>
<pre><code class="language-bash">sudo vim /etc/systemd/system/frps.service
</code></pre>
<pre><code>[Unit]
Description=frps
After=network.target
[Service]
TimeoutStartSec=30
WorkingDirectory=/usr/local/bin/
ExecStart=/usr/local/bin/frps -c /usr/local/etc/frp/frps.ini
Restart=on-failure
[Install]
WantedBy=multi-user.target
</code></pre>
<p>保存后，执行：</p>
<pre><code>sudo systemctl enable frps
sudo systemctl start frps
sudo systemctl status frps
</code></pre>
<p>若无问题，则可进入客户端的配置。</p>
<p>下面是一些常用的命令：</p>
<ul>
<li>启动服务：<code>sudo systemctl start frps</code></li>
<li>停止服务：<code>sudo systemctl stop frps</code></li>
<li>重启服务：<code>sudo systemctl restart frps</code></li>
<li>查看服务状态：<code>sudo systemctl status frps</code></li>
<li>关闭自启动：<code>sudo systemctl disable frps</code></li>
</ul>
<h3>客户端配置</h3>
<p>下载完对应架构的文件后，即可开始配置，只需要关心 <code>frpc</code> 和 <code>frpc.ini</code> 文件即可，前者是FRP 客户端的可执行文件，后者是这是 FRP 客户端的配置文件。</p>
<p><strong>假设：</strong></p>
<p><strong>服务器的ip地址是 1.1.1.1, 服务端frp正在监听的端口是7000, token是1234567890</strong></p>
<p><strong>客户端目前正在运行一个项目叫 bitwarden ,它正在本地 0.0.0.0 地址上监听 1111 端口</strong></p>
<p>打开 <code>frpc.ini</code>进行配置，配置文件的内容如下：</p>
<pre><code>[common]
server_addr = 1.1.1.1
server_port = 7000
token = 1234567890

[bitwarden]
type = tcp
local_ip = 0.0.0.0
local_port = 1111
remote_port = 8111
</code></pre>
<p>值得注意的是，配置文件中的 [bitwarden] 可以替换成任何想要的名字</p>
<p>为了方便，我们同样设置 systemd 服务</p>
<p>但是在此之前，我们需要先将 <code>frpc</code> 和 <code>frpc.ini</code> 文件放到合适的地方：</p>
<pre><code>sudo cp frpc /usr/local/bin/
sudo mkdir /usr/local/etc/frp
sudo cp frpc.ini /usr/local/etc/frp/
</code></pre>
<p>首先，创建一个名为<code>frpc.service</code>的文件，该文件将存储有关你的自启动服务的信息。通常，这些文件存放在<code>/etc/systemd/system/</code>目录下。</p>
<pre><code class="language-bash">sudo vim /etc/systemd/system/frpc.service
</code></pre>
<pre><code>[Unit]
Description=frpc
After=network.target
[Service]
TimeoutStartSec=30
WorkingDirectory=/usr/local/bin/
ExecStart=/usr/local/bin/frpc -c /usr/local/etc/frp/frpc.ini
Restart=on-failure
[Install]
WantedBy=multi-user.target
</code></pre>
<p>保存后，执行：</p>
<pre><code>sudo systemctl enable frpc
sudo systemctl start frpc
sudo systemctl status frpc
</code></pre>
<p>若无问题的话，则说明没有问题！</p>
<h3>原理</h3>
<p>Frp（Fast Reverse Proxy）是一个用于内网穿透的工具，它允许你在公网上访问位于内网的计算机服务。它的原理是通过在公网服务器上部署 frps（Frp 服务器端）和在内网机器上部署 frpc（Frp 客户端），通过公网服务器作为中转，将外部请求转发到内网机器上。</p>
<ul>
<li>在公网服务器上部署 frps：公网服务器上运行的 frps 监听一个指定的端口，等待来自 frpc 的连接。</li>
<li>在内网机器上部署 frpc：内网机器上的 frpc 将建立到 frps 的连接，并注册自己的服务信息。frpc 和 frps 之间建立的连接可以被用于穿透数据。</li>
<li>数据传输：当公网客户端请求连接到公网服务器的指定端口时，frps 会将这个请求转发给已经连接的 frpc 客户端，然后 frpc 客户端再将请求转发到内网机器的指定服务上。</li>
</ul>
<p>在我上面的配置中，其转换的意思就是：</p>
<p>frps 监听在公网服务器的 7000 端口，frpc 连接到公网服务器的 7000 端口，并注册自己的服务信息。frpc 客户端配置了一个类型为 TCP 的服务，将本地的 bitwarden 服务映射到公网服务器的 8111 端口上。</p>
<p>若是请求 https://1.1.1.1:8111 那么这个请求就转发给客户端的 http://0.0.0.0:1111</p>
<h3>Nginx 配置</h3>
<p>我在服务器中是使用 Nginx 来进行反向代理的，若你的服务器不是，则可以跳过此内容。<strong>若你完全不了解 nginx 建议先去学习了之后再回来进行配置，因为此处我写得很简略，可能会对你产生误导。</strong></p>
<p>我的 Nginx 代理了80端口，所有的请求都是从此处进入上文提到，需要从 8111 端口进入才能访问内网，所以我需要对 nginx 添加一些配置：</p>
<p><img src="https://s2.loli.net/2023/08/27/RrNxIVbkSTgGQOy.png" alt="2023-08-17_15-48.png" /></p>
<p>这样，当请求 bitwarden 路径时，将会反向代理到 8111 端口</p>
<p>当然，通过 nginx 也可以配置子域名来访问，首先将三级域名 bitwarden.yarnom.top 通过 CNAME 指向当前的服务器地址</p>
<p>然后，nginx 设置一个新的 server ，server_name 就是这个三级域名：</p>
<p><img src="https://s2.loli.net/2023/08/27/DjX7LebSQftPovT.png" alt="2023-08-17_15-26.png" /></p>
<h2>搭建 <strong><a href="https://github.com/dani-garcia/vaultwarden">Vaultwarden</a></strong></h2>
<p>由于官方的 Bitwarden 服务对于我的小机子来说过于庞大了，所以选择了社区用 Rust 编写 Vaultwarden 项目</p>
<p>它可以用 docker 搭建，那就是几条命令就能安装完毕：</p>
<pre><code>Pull the docker image and mount a volume from the host for persistent storage:

docker pull vaultwarden/server:latest
docker run -d --name vaultwarden -v /vw-data/:/data/ --restart unless-stopped -p 80:80 vaultwarden/server:latest
</code></pre>
<p>完成！</p>
<h3>搭建 <a href="https://github.com/usememos/memos">Memos</a></h3>
<p>docker 搭建</p>
<pre><code>docker run -d --name memos -p 5230:5230 -v ~/.memos/:/var/opt/memos ghcr.io/usememos/memos:latest
</code></pre>
<p>自行修改参数即可。</p>
<p>完成！</p>
</div>
                <div class="tags_post">
                    
                    <li><a href="/archive/tags/Orangepi">Orangepi</a></li>
                    
                    <li><a href="/archive/tags/Linux">Linux</a></li>
                    
                    <li><a href="/archive/tags/Nginx">Nginx</a></li>
                    
                </div>
            </div>
        </div>
    
        <div class="articles">
            <div class="post">
                <div class="header_post">
                    <div class="title_post"><a href="&#x2F;archive&#x2F;posts&#x2F;2023&#x2F;8&#x2F;8&#x2F;七月与八月.html">七月与八月</a></div>
                    <div class="detail_post">
                        <div class="date">发布时间：2023-08-08 22:51:43</div>
                        <div class="categories">
                            归档分类：
                            <ul>
                                
                                <li><a href="/archive/categories/随笔">随笔</a></li>
                                
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="content_post"><p>七月就这样过去了呢，很久没有写博文了，主要是生活现在千篇一律，没啥想写的内容，总不能写一大堆的流水账不是嘛。</p>
<p>虽说是千篇一律，但最近也是有好好用功的。最近在捣鼓一个新的项目：用 Rust 语言完成静态博客生成器。我目前使用的 Hexo 就是这样的工具，它将markdown文件转换为html文件，再对 tags 和 categories 等内容进行整理。这是之前未曾接触过的代码经历。</p>
<p>事实上，一开始为真的无从下手，于是我开始询问 ChatGPT，这真是一个很棒的人工智能，它认真地回答了我很多的问题，给予了我很多实际地代码。我用了一天时间了解了 rust 的语法，囫囵吞枣地学习显然不足以支撑我完成这个项目，但是有了 ChatGPT 的帮助，事情真的变得容易了很多，之后完成了这个项目，我会写一篇更详细的文章来介绍这一过程。</p>
</div>
                <div class="tags_post">
                    
                    <li><a href="/archive/tags/思考">思考</a></li>
                    
                </div>
            </div>
        </div>
    
        <div class="articles">
            <div class="post">
                <div class="header_post">
                    <div class="title_post"><a href="&#x2F;archive&#x2F;posts&#x2F;2023&#x2F;6&#x2F;14&#x2F;🎉 评论区功能上线.html">🎉 评论区功能上线</a></div>
                    <div class="detail_post">
                        <div class="date">发布时间：2023-06-14 17:29:46</div>
                        <div class="categories">
                            归档分类：
                            <ul>
                                
                                <li><a href="/archive/categories/开发">开发</a></li>
                                
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="content_post"><p>今天上线了友链，于是寻思着把评论区也添加上，使用的是 <a href="https://giscus.app/zh-CN">giscus</a> ，这是利用 <a href="https://docs.github.com/en/discussions">GitHub Discussions</a> 实现的评论系统。</p>
</div>
                <div class="tags_post">
                    
                    <li><a href="/archive/tags/网站维护">网站维护</a></li>
                    
                    <li><a href="/archive/tags/开发记录">开发记录</a></li>
                    
                </div>
            </div>
        </div>
    
        <div class="articles">
            <div class="post">
                <div class="header_post">
                    <div class="title_post"><a href="&#x2F;archive&#x2F;posts&#x2F;2023&#x2F;6&#x2F;14&#x2F;🎉 友链功能上线.html">🎉 友链功能上线</a></div>
                    <div class="detail_post">
                        <div class="date">发布时间：2023-06-14 16:03:31</div>
                        <div class="categories">
                            归档分类：
                            <ul>
                                
                                <li><a href="/archive/categories/开发">开发</a></li>
                                
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="content_post"><p>今日和朋友闲聊，话题扯到了我们各自的博客上，我周围写博客的人还是蛮少的，很高兴他也一直在写博客，于是我们便萌生了交换友链的想法。</p>
<p>但问题在于，我的博客并没有这个功能，但是 Hexo 完成这个功能也简单，这也是静态博客的一大优势，代码的实现非常简单。</p>
<p>于是在经过了两分钟的编程后，我正式宣布我的博客友链功能正式上线 ！！！🎉🎉🎉</p>
</div>
                <div class="tags_post">
                    
                    <li><a href="/archive/tags/网站维护">网站维护</a></li>
                    
                    <li><a href="/archive/tags/开发记录">开发记录</a></li>
                    
                </div>
            </div>
        </div>
    
        <div class="articles">
            <div class="post">
                <div class="header_post">
                    <div class="title_post"><a href="&#x2F;archive&#x2F;posts&#x2F;2023&#x2F;6&#x2F;14&#x2F;忙.html">忙</a></div>
                    <div class="detail_post">
                        <div class="date">发布时间：2023-06-14 12:20:18</div>
                        <div class="categories">
                            归档分类：
                            <ul>
                                
                                <li><a href="/archive/categories/随笔">随笔</a></li>
                                
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="content_post"><p>最近事情真的很多，实训整得我莫名其妙地很累，也没啥时间写博文，况且静态博客的弊端就是无法随时地去写啦，最近想着要不要用 java 去搭建一个服务，上面用来写一些短的评论或者吐槽的话语，目前的初步想法是这样的。</p>
</div>
                <div class="tags_post">
                    
                    <li><a href="/archive/tags/post">post</a></li>
                    
                </div>
            </div>
        </div>
    
        <div class="articles">
            <div class="post">
                <div class="header_post">
                    <div class="title_post"><a href="&#x2F;archive&#x2F;posts&#x2F;2023&#x2F;5&#x2F;22&#x2F;V2ray 搭建与配置记录.html">V2ray 搭建与配置记录</a></div>
                    <div class="detail_post">
                        <div class="date">发布时间：2023-05-22 12:34:43</div>
                        <div class="categories">
                            归档分类：
                            <ul>
                                
                                <li><a href="/archive/categories/v2ray">v2ray</a></li>
                                
                                <li><a href="/archive/categories/教程">教程</a></li>
                                
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="content_post"><h2>前言</h2>
<p>近来想纯净自己的ip，同时也想试着搭建 v2ray 服务供以自己代理使用，所以上两个星期便购买了一台 Vultr 的 VPS。出现了一些问题，同时也确实都得以解决了，这里将问题和解决办法列出：</p>
<h3>1. 未做伪装的 ip 被封杀</h3>
<p>这是第一次尝试使用 vps 搭建 v2ray 服务，事实上非常的顺利，我确实完成了 v2ray 的搭建，但是第三天便遭到了中国政府的防火墙一记 ban ip 操作。现在想着这是极为危险的，但事情还得继续，问题自然是发生在我未对 v2ray 进行伪装，因为初次接触，所以对很多新的名词有恐惧心理，一开始便没有去尝试伪装操作，最终酿下错误，但是错误的本身其实也在推动着我技术的进步。</p>
<p>问题的解决方法是，首先通过 WebSocket+TLS+Web 完成对传输层流量伪装，原理就是通过 Nginx 搭建了一个真实的网站，分流一个特定的路由去转发 v2ray 的流量，其实正常的伪装到这里就结束了。但前面我说了，我的 VPS ip 被封杀了，其导致了我没办法在国内正常通过 ssh 访问到服务器，所以根据攻略我又加了一层伪装，我将我的域名名服务器交给 cloudflare 让其帮我把域名伪装成其他的ip，从而躲过封杀。</p>
<p>这样的后果也很明显，虽然更加安全了，但是代理速度确实也下来了。。。于是，我还是决定摧毁当前的 vps ，重新构建一个，Vulter 会重新分配一个 新的ip。</p>
<h3>2. ChatGPT 封杀所有 vultr 的 ip</h3>
<p>如小标题所言，openai 确实封杀了所有来自 vultr 的 ip，但是这个问题不大，我还是通过 cloundflare 单独对这个域名伪装了 ip 得以成功使用chatgpt，这个在后文中会详细讲到。</p>
<h2>配置 vps 和 v2ray</h2>
<h3>修改 hostname</h3>
<p>这个对v2ray 没啥子用，只是我想改而已：）</p>
<pre><code>vim /etc/hostname

</code></pre>
<h3>安装 git</h3>
<pre><code>apt-get install git
</code></pre>
<h3>安装 zsh 和 ohmyzsh</h3>
<p>Linux 自带的 bash 不是那么地方便使用，所以换成 zsh 是个更好的选择。</p>
<pre><code>apt-get install zsh
sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;
</code></pre>
<h3>安装 v2ray</h3>
<h4>通过官方脚本自动安装 v2ray 本体</h4>
<p>确实有很多种方式安装 v2ray，我这里选择使用 <code>fhs-install-v2ray</code> 项目提供的安装脚本进行安装：
主要是它能帮我自动创建一些文件：</p>
<pre><code>installed: /usr/local/bin/v2ray
installed: /usr/local/bin/v2ctl
installed: /usr/local/share/v2ray/geoip.dat
installed: /usr/local/share/v2ray/geosite.dat
installed: /usr/local/etc/v2ray/config.json
installed: /var/log/v2ray/
installed: /var/log/v2ray/access.log
installed: /var/log/v2ray/error.log
installed: /etc/systemd/system/v2ray.service
installed: /etc/systemd/system/v2ray@.service
</code></pre>
<p>执行下面的程序脚本即可（目前时间是：2023-05-22，该脚本未来可能发生变动，以具体情况为准）
此处贴出项目 README 文件：<a href="&#x27;https://github.com/v2fly/fhs-install-v2ray/blob/master/README.zh-Hans-CN.md&#x27;">README.zh</a></p>
<pre><code>bash &lt;(curl -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh)
</code></pre>
<p>执行完后，若无明显错误，即可通过 <code>systemctl start v2ray.service</code> 和 <code>systemctl status v2ray.service</code> 查看是否能正确启动。</p>
<h4>配置 v2ray 服务端</h4>
<p>无论是服务端亦或是客户端的配置，其实都非常简单，只需要将配置文件改动一些即可使用。
以下是官方提供的服务端配置：</p>
<pre><code class="language-json">{
    &quot;inbounds&quot;: [
        {
            &quot;port&quot;: 10086, // 服务器监听端口
            &quot;protocol&quot;: &quot;vmess&quot;,
            &quot;settings&quot;: {
                &quot;clients&quot;: [
                    {
                        &quot;id&quot;: &quot;xxxxxxxxxxxxxxx&quot;
                    }
                ]
            }
        }
    ],
    &quot;outbounds&quot;: [
        {
            &quot;protocol&quot;: &quot;freedom&quot;
        }
    ]
}
</code></pre>
<p>在入门阶段，只需要了解 <code>inbounds</code> 中的 <code>port</code> 和 <code>id</code> 即可。</p>
<ul>
<li><code>port</code> 即是服务器的监听端口</li>
<li><code>id</code> 可以理解为某种密钥一样的存在，在服务端与客户端交流时，需要通过这值进行辨别身份。可以使用 <code>cat /proc/sys/kernel/random/uuid</code> 指令生成这个 id。</li>
</ul>
<blockquote>
<p>服务器的配置中需要确保 id 和端口与客户端一致，就可以正常连接了。</p>
</blockquote>
<p>最后重启一下 v2ray 服务即可：<code>systemctl restart v2ray.service</code> ，当然因为可能存在的将配置文件写错的问题，最好再查看一下有没有错误产生 <code>systemctl status v2ray.service</code></p>
<p>没有问题后，即可开始配置 v2ray 客户端。</p>
<p>啊，最后注意让防火墙放开对应的端口，比如这里的10086端口</p>
<pre><code>ufw allow 10086/tcp
</code></pre>
<h3>配置 v2ray 客户端</h3>
<ul>
<li>Linux 平台可以使用 v2ray 程序(服务器所用的那个)，它即可以当服务端也可以作为客户端使用</li>
<li>Android 平台可以使用 v2rayNG</li>
</ul>
<p>无论是 android 还是 windows，其都有相应的图形界面，配置起来很简单，这里主要讲一下 v2ray 如何作为客户端使用。</p>
<p>以下贴出官方提供的客户端配置：</p>
<pre><code class="language-json">{
    &quot;inbounds&quot;: [
        {
            &quot;port&quot;: 1080, // SOCKS 代理端口，在浏览器中需配置代理并指向这个端口
            &quot;listen&quot;: &quot;127.0.0.1&quot;,
            &quot;protocol&quot;: &quot;socks&quot;,
            &quot;settings&quot;: {
                &quot;udp&quot;: true
            }
        }
    ],
    &quot;outbounds&quot;: [
        {
            &quot;protocol&quot;: &quot;vmess&quot;,
            &quot;settings&quot;: {
                &quot;vnext&quot;: [
                    {
                        &quot;address&quot;: &quot;server&quot;, // 服务器地址，请修改为你自己的服务器 ip 或域名
                        &quot;port&quot;: 10086, // 服务器端口
                        &quot;users&quot;: [
                            {
                                &quot;id&quot;: &quot;b831381d-6324-4d53-ad4f-8cda48b30811&quot;
                            }
                        ]
                    }
                ]
            }
        },
        {
            &quot;protocol&quot;: &quot;freedom&quot;,
            &quot;tag&quot;: &quot;direct&quot;
        }
    ],
    &quot;routing&quot;: {
        &quot;domainStrategy&quot;: &quot;IPOnDemand&quot;,
        &quot;rules&quot;: [
            {
                &quot;type&quot;: &quot;field&quot;,
                &quot;ip&quot;: [
                    &quot;geoip:private&quot;
                ],
                &quot;outboundTag&quot;: &quot;direct&quot;
            }
        ]
    }
}
</code></pre>
<p>虽然这看起来蛮多的，但需要修改的地方也就是 <code>outbounds</code> 里的 <code>address</code>、<code>port</code> 和 <code>id</code></p>
<ul>
<li><code>address</code> 填入 vps 的 ip 地址亦或是域名</li>
<li><code>port</code> 填入服务端中监听的那个地址</li>
<li><code>id</code> 填入服务端的 id</li>
</ul>
<p>这样一切弄完后，在配置一下 <code>socks_proxy</code> 的环境变量即可。</p>
<pre><code>export socks_proxy=https://127.0.0.1:1080;&quot;
</code></pre>
<p>当然也可以把 <code>http_proxy</code> 和 <code>https_proxy</code> 代理填入。</p>
<p>若是你想在浏览器使用：</p>
<ul>
<li>firefox 相对方便，直接在设置中选择 socks5 代理，地址即填入配置文件中的：<code>127.0.0.1:1080</code></li>
<li>chrome 可以去下载 名为 <code>SwitchyOmega</code> 的插件，也使用 sock5 配置即可</li>
</ul>
<h3>使用 WebSocket+TLS+Web 完成伪装</h3>
<p>此处先给出参考的文章引用，在文章末尾也会重复给出，感谢各位前辈的教程。</p>
<ul>
<li><a href="&#x27;https://www.v2fly.org/guide/install.html&#x27;">V2Fly</a></li>
<li><a href="&#x27;https://whuwangyong.vercel.app/2023-03-18-v2ray-websocket-tls-web-cloudflare-guide/&#x27;">V2Ray+WebSocket+TLS+Web+Cloudflare教程</a></li>
<li><a href="&#x27;https://linuxfunk.com/2017/10/31/v2ray-ws-tls-nginx%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93/&#x27;">linuxfunk</a></li>
<li><a href="&#x27;https://cyfeng.science/2020/03/22/advanced-v2ray-with-wss/&#x27;">V2Ray进阶指南：WSS组合配置(WebSocket + TLS + Nginx + CDN)</a></li>
</ul>
<p>在完成了之前那些操作后，自然是可以正常使用 v2ray 的，但是非常容易被封杀(我的坚持了两天hhhhh)，这也是我后来才得知道的 :(</p>
<p>总之，被封杀了我便意识到了伪装是极其重要的，以下先介绍一些概念名称，我刚开始接触这一部分便直接放弃了，但遗憾的是这一部分却又不得不学，GFW 太强啦，我们只能被迫去与之对抗。</p>
<h4>TLS</h4>
<p><code>TLS 加密</code>，TLS 中文叫 传输层安全性协议，以下是 wikipedia 的描述：</p>
<blockquote>
<p>将通信两方交换的资料做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听</p>
</blockquote>
<p>这是用来加密的，广为人知的 <code>HTTP</code> 在经过 TLS 加密后，成为了<code>HTTPS</code></p>
<p>若是 v2ray 的流量没有被 TLS 加密，那么审查者便能根据数据内容分析出，这是违“法”的数据，而且代理流量源源不断地从固定 ip 发来，这样的流量同样是不正常的。</p>
<h4>网站前置伪装 与 websocket 协议</h4>
<p>仅用 TLS 加密依旧是不够的，因为流量不正常，这些大规模的流量因为代理的原因来去于同一个ip，这样的流量即使是加密的，也应该是有问题的。所以，需要再完成一次伪装，使用 Nginx 与 域名 搭建一个真实的网站，我们的客户端通过 websocket（ws）协议与这个用 Nginx 作为前端的网站进行数据交流，这样一来，我们的服务器就是正儿八经的网站服务器（事实也确实如此），而非代理服务器，在找到某种特征之前，不可能大面积封杀这样的正常服务器。</p>
<p>使用，我们现在的任务很简单，购买一个域名（可以是免费的二级域名），在我们的 VPS 中通过 Nginx 搭建一个真实但简单的网站，然后让客户端和服务器端通过ws协议交流，接着通过 Nginx 分流特定的路由。</p>
</div>
                <div class="tags_post">
                    
                    <li><a href="/archive/tags/VPS">VPS</a></li>
                    
                    <li><a href="/archive/tags/v2ray">v2ray</a></li>
                    
                </div>
            </div>
        </div>
    
    <div class="paginator">
    
        <a href="&#x2F;" class="extend prev">上一页</a>
    
        <a href="" class="page_number current">2</a>
    
        <a href="&#x2F;page&#x2F;3" class="extend next">下一页</a>
    

</div>

        </div>
    </div>

    
</body>
<footer>
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>
</footer> 
</html>
